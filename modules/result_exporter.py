# -*- coding: utf-8 -*-
"""
Advanced Result Exporter with Multiple Formats
"""

import os
import json
import csv
from datetime import datetime
from typing import List, Dict, Any, Optional

try:
    from rich.console import Console
    from rich.progress import Progress
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False


class ResultExporter:
    """Export search results in various formats"""
    
    def __init__(self, config, logger):
        self.config = config
        self.logger = logger
        self.results_path = config.get('results_path', 'results')
        os.makedirs(self.results_path, exist_ok=True)
        
        if RICH_AVAILABLE:
            self.console = Console()
    
    def export(self, results: List[Dict], query: str, format: str = None) -> Optional[str]:
        """Export results to file"""
        if not results:
            return None
        
        format = format or self.config.get('export_format', 'txt')
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Create safe filename
        safe_query = "".join(c for c in query if c.isalnum() or c in ' _-')[:30].strip()
        safe_query = safe_query.replace(' ', '_')
        
        filename = f"search_{safe_query}_{timestamp}"
        
        if format == 'txt':
            return self._export_txt(results, query, filename)
        elif format == 'csv':
            return self._export_csv(results, query, filename)
        elif format == 'json':
            return self._export_json(results, query, filename)
        elif format == 'html':
            return self._export_html(results, query, filename)
        else:
            return self._export_txt(results, query, filename)
    
    def _export_txt(self, results: List[Dict], query: str, filename: str) -> str:
        """Export to TXT format"""
        filepath = os.path.join(self.results_path, f"{filename}.txt")
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"  SEARCH RESULTS\n")
                f.write(f"  Query: {query}\n")
                f.write(f"  Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"  Found: {len(results)} records\n")
                f.write("=" * 80 + "\n\n")
                
                for i, result in enumerate(results, 1):
                    f.write(f"[{i}] File: {result.get('file', 'N/A')}\n")
                    f.write(f"    Line: {result.get('line_number', 'N/A')}\n")
                    f.write(f"    Data: {result.get('raw_data', '')}\n")
                    
                    parsed = result.get('parsed', {})
                    if parsed:
                        f.write(f"    Parsed fields:\n")
                        for key, value in parsed.items():
                            f.write(f"      - {key}: {value}\n")
                    
                    f.write("-" * 80 + "\n")
                
                f.write(f"\n\nGenerated by DB Search Tool v2.0\n")
            
            self.logger.info(f"TXT export: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"TXT export error: {e}")
            return None
    
    def _export_csv(self, results: List[Dict], query: str, filename: str) -> str:
        """Export to CSV format"""
        filepath = os.path.join(self.results_path, f"{filename}.csv")
        
        try:
            with open(filepath, 'w', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f, delimiter=';')
                
                # Headers
                writer.writerow([
                    '#', 'File', 'Line', 'Raw Data', 
                    'Telegram ID', 'Phone', 'Email', 'Username', 
                    'First Name', 'Last Name', 'Patronymic'
                ])
                
                for i, result in enumerate(results, 1):
                    parsed = result.get('parsed', {})
                    writer.writerow([
                        i,
                        result.get('file', ''),
                        result.get('line_number', ''),
                        result.get('raw_data', ''),
                        parsed.get('telegram_id', ''),
                        parsed.get('phone', ''),
                        parsed.get('email', ''),
                        parsed.get('username', ''),
                        parsed.get('first_name', ''),
                        parsed.get('last_name', ''),
                        parsed.get('patronymic', '')
                    ])
            
            self.logger.info(f"CSV export: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"CSV export error: {e}")
            return None
    
    def _export_json(self, results: List[Dict], query: str, filename: str) -> str:
        """Export to JSON format"""
        filepath = os.path.join(self.results_path, f"{filename}.json")
        
        try:
            export_data = {
                'query': query,
                'timestamp': datetime.now().isoformat(),
                'total_results': len(results),
                'export_format': 'json',
                'tool': 'DB Search Tool v2.0',
                'results': results
            }
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, ensure_ascii=False, indent=2)
            
            self.logger.info(f"JSON export: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"JSON export error: {e}")
            return None
    
    def _export_html(self, results: List[Dict], query: str, filename: str) -> str:
        """Export to HTML format with styling"""
        filepath = os.path.join(self.results_path, f"{filename}.html")
        
        try:
            html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Results: {query}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        h1 {{
            color: #00d4ff;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }}
        .info {{
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            overflow: hidden;
        }}
        th {{
            background: linear-gradient(90deg, #00d4ff, #0099cc);
            color: #000;
            padding: 15px;
            text-align: left;
        }}
        td {{
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }}
        tr:hover {{
            background: rgba(0, 212, 255, 0.1);
        }}
        .parsed {{
            color: #00ff88;
            font-size: 0.9em;
        }}
        .footer {{
            text-align: center;
            margin-top: 30px;
            color: #666;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Search Results</h1>
        <div class="info">
            <strong>Query:</strong> {query} | 
            <strong>Found:</strong> {len(results)} results | 
            <strong>Date:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        </div>
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>File</th>
                    <th>Line</th>
                    <th>Data</th>
                    <th>Parsed Fields</th>
                </tr>
            </thead>
            <tbody>
"""
            
            for i, result in enumerate(results, 1):
                parsed = result.get('parsed', {})
                parsed_str = '<br>'.join([f"{k}: {v}" for k, v in parsed.items()]) or '-'
                raw_data = result.get('raw_data', '')[:100]
                
                html_content += f"""                <tr>
                    <td>{i}</td>
                    <td>{result.get('file', 'N/A')}</td>
                    <td>{result.get('line_number', 'N/A')}</td>
                    <td>{raw_data}</td>
                    <td class="parsed">{parsed_str}</td>
                </tr>
"""
            
            html_content += """            </tbody>
        </table>
        <div class="footer">
            Generated by DB Search Tool v2.0
        </div>
    </div>
</body>
</html>"""
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"HTML export: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"HTML export error: {e}")
            return None
    
    def list_exports(self) -> List[str]:
        """List all exported files"""
        files = []
        for f in os.listdir(self.results_path):
            if f.startswith('search_'):
                files.append(f)
        return sorted(files, reverse=True)
